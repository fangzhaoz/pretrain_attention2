import os
import sys
with open(sys.argv[0]) as f:
    code = f.read() # read the code of this file ASAP, for logging
import uuid
import time
import copy
from dataclasses import dataclass
from functools import lru_cache
from pathlib import Path

os.environ["PYTORCH_CUDA_ALLOC_CONF"] = "expandable_segments:True"
import torch
torch.empty(1, device="cuda", requires_grad=True).backward() # prevents a bug on some systems
from torch import Tensor, nn
import torch.nn.functional as F
import torch.distributed as dist
# use of FlexAttention contributed by @KoszarskyB
from torch.nn.attention.flex_attention import BlockMask, flex_attention
torch._inductor.config.coordinate_descent_tuning = True # we allow this flag for medium track
torch._dynamo.config.compiled_autograd = False

# -----------------------------------------------------------------------------
# Muon optimizer

def zeropower_via_newtonschulz5(G: Tensor) -> Tensor:
    """
    Newton-Schulz iteration to compute the zeroth power / orthogonalization of G. We opt to use a
    quintic iteration whose coefficients are selected to maximize the slope at zero. For the purpose
    of minimizing steps, it turns out to be empirically effective to keep increasing the slope at
    zero even beyond the point where the iteration no longer converges all the way to one everywhere
    on the interval. This iteration therefore does not produce UV^T but rather something like US'V^T
    where S' is diagonal with S_{ii}' ∈ [1 - l, 1 + r], which turns out not to hurt model
    performance at all relative to UV^T, where USV^T = G is the SVD.
    """
    assert G.ndim >= 2 # batched Muon implementation by @scottjmaddox, and put into practice in the record by @YouJiacheng
    X = G.bfloat16()
    if G.size(-2) > G.size(-1):
        X = X.mT

    # Ensure spectral norm is at most 1
    X = X / (X.norm(dim=(-2, -1), keepdim=True) + 1e-7)
    # Perform the NS iterations
    for a, b, c in [
        (4.0848, -6.8946, 2.9270),
        (3.9505, -6.3029, 2.6377),
        (3.7418, -5.5913, 2.3037),
        (2.8769, -3.1427, 1.2046),
        (2.8366, -3.0525, 1.2012),
    ]:
        A = X @ X.mT
        B = b * A + c * A @ A # quintic computation strategy adapted from suggestion by @jxbz, @leloykun, and @YouJiacheng
        X = a * X + B @ X

    if G.size(-2) > G.size(-1):
        X = X.mT
    return X

@torch.compile
def update(acc_bf16_view_u16: Tensor, mantissa: Tensor, momentum_buffer: Tensor, grad: Tensor, momentum: Tensor, eff_lr: Tensor, eff_weight_decay: Tensor):
    assert acc_bf16_view_u16.dtype == mantissa.dtype == torch.uint16
    grad = grad.float()
    momentum_buffer.copy_(momentum * momentum_buffer + (1 - momentum) * grad)
    v = zeropower_via_newtonschulz5(momentum * momentum_buffer + (1 - momentum) * grad)

    acc_m_u32 = (acc_bf16_view_u16.to(torch.uint32) << 16) | mantissa.to(torch.uint32)

    # # ---------- vanilla weight decay decay ----------
    # acc_m_u32.view(torch.float32).mul_(1 - eff_weight_decay)

    # # ---------- L1-CWD decay ----------
    # x_fp = acc_m_u32.view(torch.float32) 
    # mask = (x_fp * v) > 0 
    # x_fp[mask].mul_(1.0 - eff_weight_decay)

    # # ---------- L2-CWD decay: + eff_weight_decay * (I - Π_u) x ----------
    # # Π_u x = ( <x,u> / <u,u> ) * u , with Frobenius inner products
    # x_fp = acc_m_u32.view(torch.float32) 
    # eps = torch.finfo(torch.float32).eps
    # dot_xu = (x_fp * v).sum()
    # dot_uu = (v * v).sum().clamp_min(eps)
    # proj_coeff = dot_xu / dot_uu
    # proj_on_u = proj_coeff * v              # Π_u x
    # x_perp = x_fp - proj_on_u               # (I - Π_u) x
    # x_fp.add_(x_perp, alpha=-eff_weight_decay)  # + ηλ (I - Π) x ; here eff_weight_decay already includes ηλ


    # # ---------- L2-CWD decay clamp: + eff_weight_decay * (I - Π_u) x ----------
    # # Π_u x = ( <x,u> / <u,u> ) * u , with Frobenius inner products
    # x_fp = acc_m_u32.view(torch.float32) 
    # eps = torch.finfo(torch.float32).eps
    # dot_xu = (x_fp * v).sum().clamp_max(0.0)
    # dot_uu = (v * v).sum().clamp_min(eps)
    # proj_coeff = dot_xu / dot_uu
    # proj_on_u = proj_coeff * v             
    # x_perp = x_fp - proj_on_u              
    # x_fp.add_(x_perp, alpha=-eff_weight_decay) 


    # # ---------- Spectral-CWD (Schatten-∞), strict orthogonal (2D or 3D safe) ----------
    # x_fp = acc_m_u32.view(torch.float32)
    # eps = x_fp.new_tensor(1e-12)

    # # Build Gram: for 2D X:(m,n), Gram = X^T X (n,n);
    # # for 3D X:(b,m,n), Gram = sum_i X_i^T X_i  (n,n)
    # gram = x_fp.mT @ x_fp                 # (n,n) or (b,n,n)
    # if gram.ndim == 3:
    #     gram = gram.sum(dim=0)            # (n,n) aggregate over the leading dim
    # gram = gram + eps * torch.eye(gram.shape[0], device=gram.device, dtype=gram.dtype)

    # # Top right singular vector via eigh(Gram)
    # evals, evecs = torch.linalg.eigh(gram) # (n,), (n,n)
    # v_r = evecs[:, -1]                     # top eigenvector (right singular)

    # # Spectral payload G_inf = X v v^T, supports 2D and 3D X
    # vvT = v_r[:, None] @ v_r[None, :]      # (n,n)
    # G_inf = x_fp @ vvT                     # (m,n) or (b,m,n)

    # # Project payload orthogonal to base step 'v' (Muon update tensor)
    # den = (v * v).sum().clamp_min(eps)
    # dot = (G_inf * v).sum()
    # proj_on_u = (dot / den) * v
    # d_spec = G_inf - proj_on_u

    # # Apply decay: -ηλ * d_spec  (eff_weight_decay already equals ηλ)
    # x_fp.add_(d_spec, alpha=-eff_weight_decay)



    # # ---------- Spectral-CWD (Schatten-∞) clamp, strict orthogonal (2D or 3D safe) ----------
    # x_fp = acc_m_u32.view(torch.float32)
    # eps = x_fp.new_tensor(1e-12)

    # # Build Gram: for 2D X:(m,n), Gram = X^T X (n,n);
    # # for 3D X:(b,m,n), Gram = sum_i X_i^T X_i  (n,n)
    # gram = x_fp.mT @ x_fp                 # (n,n) or (b,n,n)
    # if gram.ndim == 3:
    #     gram = gram.sum(dim=0)            # (n,n) aggregate over the leading dim
    # gram = gram + eps * torch.eye(gram.shape[0], device=gram.device, dtype=gram.dtype)

    # # Top right singular vector via eigh(Gram)
    # evals, evecs = torch.linalg.eigh(gram) # (n,), (n,n)
    # v_r = evecs[:, -1]                     # top eigenvector (right singular)

    # # Spectral payload G_inf = X v v^T, supports 2D and 3D X
    # vvT = v_r[:, None] @ v_r[None, :]      # (n,n)
    # G_inf = x_fp @ vvT                     # (m,n) or (b,m,n)

    # # Project payload orthogonal to base step 'v' (Muon update tensor)
    # den = (v * v).sum().clamp_min(eps)
    # dot = (G_inf * v).sum().clamp_max(0.0)
    # proj_on_u = (dot / den) * v
    # d_spec = G_inf - proj_on_u

    # # Apply decay: -ηλ * d_spec  (eff_weight_decay already equals ηλ)
    # x_fp.add_(d_spec, alpha=-eff_weight_decay) 


    # # ---------- Spectral WD (penalized spectral norm): x <- x - η*(u + λ * a b^T) ----------
    # x_fp = acc_m_u32.view(torch.float32)
    # eps = x_fp.new_tensor(1e-12)

    # # Build Gram: for 2D X:(m,n), Gram = X^T X (n,n);
    # # for 3D X:(b,m,n), Gram = sum_i X_i^T X_i  (n,n)  (aggregate over slices)
    # gram = x_fp.mT @ x_fp
    # if gram.ndim == 3:
    #     gram = gram.sum(dim=0)
    # gram = gram + eps * torch.eye(gram.shape[0], device=gram.device, dtype=gram.dtype)

    # # Top right singular vector b (v_r)
    # evals, evecs = torch.linalg.eigh(gram)   # (n,), (n,n)
    # v_r = evecs[:, -1]                       # b in R^n

    # # Left singular vector a = (X v_r) / ||X v_r||
    # Av = x_fp @ v_r                          # (m,) or (b,m)
    # if Av.ndim == 1:
    #     a = Av / (Av.norm() + eps)           # (m,)
    #     # rank-1 subgradient a b^T
    #     spec_payload = a[:, None] @ v_r[None, :]   # (m,n)
    # else:
    #     a = Av / (Av.norm(dim=-1, keepdim=True) + eps)  # (b,m)
    #     spec_payload = a[..., :, None] * v_r[None, None, :]  # (b,m,n)

    # # Apply spectral penalty term: -η λ * (a b^T)
    # x_fp.add_(spec_payload, alpha=-eff_weight_decay)   # eff_weight_decay = η * λ  (spectral)


    # ---------- decoupled WD + op CWD ----------
    x_fp = ((acc_bf16_view_u16.to(torch.uint32) << 16)
            | mantissa.to(torch.uint32)).to(torch.float32)

    # split the knob
    wd_full = float(eff_weight_decay)
    wd_l2   = 0.5 * wd_full
    wd_spec = 0.5 * wd_full

    # 1) decoupled L2 WD
    if wd_l2 != 0.0:
        x_fp = x_fp * (1.0 - wd_l2)

    # 2) spectral CWD (half-space clamp), robust
    eps = x_fp.new_tensor(1e-12)

    gram = x_fp.mT @ x_fp
    if gram.ndim == 3:
        gram = gram.sum(dim=0)
    gram = 0.5 * (gram + gram.mT)
    jitter = (gram.diag().abs().mean() + eps) * 1e-6
    gram = gram + jitter * torch.eye(gram.shape[0], device=gram.device, dtype=gram.dtype)

    n = gram.shape[0]
    col_norms = x_fp.reshape(-1, n).pow(2).sum(dim=0)
    imax = int(torch.argmax(col_norms).item())
    v_r = torch.zeros(n, device=gram.device, dtype=gram.dtype)
    v_r[imax] = 1.0
    for _ in range(3):
        v_r = gram @ v_r
        v_r = v_r / (v_r.norm() + eps)

    vvT  = v_r[:, None] @ v_r[None, :]
    G_inf = x_fp @ vvT

    # cap payload
    Ginfnorm = G_inf.norm()
    cap = (x_fp.norm() + eps) * 1.0
    scale = torch.clamp(cap / (Ginfnorm + eps), max=1.0)
    G_inf = G_inf * scale

    # half-space clamp wrt v
    den = (v * v).sum()
    small_step = den <= 1e-12
    dot = (G_inf * v).sum()
    coeff = torch.where(dot < 0, dot / (den + eps), torch.zeros_like(dot))
    coeff = torch.clamp(coeff, min=-2.0, max=0.0)      # tighter clip
    proj_on_u = torch.where(small_step, torch.zeros_like(v), coeff * v)
    d_spec = G_inf - proj_on_u

    # cap spectral step and apply
    spec_step = wd_spec * d_spec
    kappa = x_fp.new_tensor(0.5)                       # tune 0.1..0.5
    spec_scale = torch.clamp(kappa * (x_fp.norm() + eps) / (spec_step.norm() + eps),
                            max=1.0)
    spec_step = spec_step * spec_scale

    x_fp = x_fp - spec_step
    x_fp = x_fp - float(eff_lr) * v

    # scrub NaNs/Infs (belt-and-suspenders)
    x_fp = torch.nan_to_num(x_fp, nan=0.0, posinf=1e4, neginf=-1e4)

    # write back
    x_u32 = x_fp.clone().view(torch.uint32)
    acc_bf16_view_u16.copy_((x_u32 >> 16).to(torch.uint16))
    mantissa.copy_(x_u32.to(torch.uint16))
    # ---------- end of decoupled WD + op CWD ----------



    # # ---------- Nuclear-norm WD (decoupled prox: SVT) ----------
    # x_fp = ((acc_bf16_view_u16.to(torch.uint32) << 16) | mantissa.to(torch.uint32)).to(torch.float32)
    # # tau = η * α   (reuse eff_weight_decay as ηα, or pass a separate eff_wd_nuc)
    # tau = eff_weight_decay
    # eps = x_fp.new_tensor(1e-12)

    # if x_fp.ndim == 2:
    #     # 2D: X ∈ R^{m×n}
    #     U, S, Vh = torch.linalg.svd(x_fp, full_matrices=False)     # (m,k), (k,), (k,n)
    #     S_shrunk = (S - tau).clamp_min(0.0)                        # soft-threshold
    #     # X_prox = U @ diag(S') @ Vh
    #     x_fp = (U * S_shrunk[None, :]) @ Vh
    # else:
    #     # 3D: X ∈ R^{b×m×n}  (apply SVT per slice)
    #     U, S, Vh = torch.linalg.svd(x_fp, full_matrices=False)     # (b,m,k), (b,k), (b,k,n)
    #     S_shrunk = (S - tau[..., None]).clamp_min(0.0)             # broadcast tau if scalar
    #     x_fp = (U * S_shrunk[..., None, :]) @ Vh                   # (b,m,k)·(b,k,n) -> (b,m,n)

    # # (Optionally: small no-op when tau=0)
    # # x_fp = torch.where((tau == 0), ((acc_bf16_view_u16.to(torch.uint32) << 16) | mantissa.to(torch.uint32)).to(torch.float32), x_fp)

    # # ---------- then do your Muon base step (preconditioned grad) ----------
    # x_fp = x_fp.add(v, alpha=-eff_lr)

    # # ---------- write back to bf16 split (no in-place on mixed-dtype views) ----------
    # x_u32 = x_fp.clone().view(torch.uint32)
    # acc_bf16_view_u16.copy_((x_u32 >> 16).to(torch.uint16))
    # mantissa.copy_(x_u32.to(torch.uint16))
    # # ---------- end of Nuclear-norm WD (decoupled prox: SVT) ----------



    # acc_m_u32.view(torch.float32).add_(other=v, alpha=-eff_lr)
    # acc_bf16_view_u16.copy_((acc_m_u32 >> 16).to(torch.uint16))
    # mantissa.copy_(acc_m_u32.to(torch.uint16))

class Muon(torch.optim.Optimizer):
    """
    Muon - MomentUm Orthogonalized by Newton-schulz

    https://kellerjordan.github.io/posts/muon/

    Muon internally runs standard SGD-momentum, and then performs an orthogonalization post-
    processing step, in which each 2D parameter's update is replaced with the nearest orthogonal
    matrix. To efficiently orthogonalize each update, we use a Newton-Schulz iteration, which has
    the advantage that it can be stably run in bfloat16 on the GPU.

    Warning: This optimizer should not be used for the embedding layer, the final fully connected layer,
    or any {0,1}-D parameters; those should all be optimized by a standard method (e.g., AdamW).
    """
    def __init__(self, params, lr=0.02, weight_decay=0.01, momentum=0.95, rank=0, world_size=1):
        self.rank = rank
        self.world_size = world_size
        defaults = dict(lr=lr, weight_decay=weight_decay, momentum=momentum)
        super().__init__(params, defaults)
        assert all(p.dtype == torch.bfloat16 for group in self.param_groups for p in group["params"])

    @torch.no_grad()
    def step(self):
        futures: list[torch.Future] = []
        for group in self.param_groups:
            params: list[Tensor] = group["params"]
            params_pad = params + [torch.empty_like(params[-1])] * self.world_size
            momentum = torch._as_tensor_fullprec(group["momentum"])
            for base_i in range(len(params))[::self.world_size]:
                if base_i + self.rank < len(params):
                    p = params[base_i + self.rank]
                    state = self.state[p]
                    if len(state) == 0:
                        state["mantissa"] = torch.zeros_like(p, dtype=torch.uint16)
                        state["momentum_buffer"] = torch.zeros_like(p, dtype=torch.float32)
                    update(
                        p.view(torch.uint16), state["mantissa"], state["momentum_buffer"],
                        p.grad, momentum,
                        eff_lr=torch._as_tensor_fullprec(group["lr"] * max(1, p.size(-2) / p.size(-1)) ** 0.5),
                        eff_weight_decay=torch._as_tensor_fullprec(group["lr"] * group["weight_decay"] * getattr(p, "wd_mul", 1.0)),
                    )
                futures.append(dist.all_gather(params_pad[base_i:base_i + self.world_size], params_pad[base_i + self.rank], async_op=True).get_future())
        torch.futures.collect_all(futures).wait()

# -----------------------------------------------------------------------------
# PyTorch nn.Module definitions for the model

def norm(x: Tensor):
    return F.rms_norm(x, (x.size(-1),))

@torch.no_grad()
def init_linear(w: Tensor):
    std = 0.5 * (w.size(-1) ** -0.5) # 0.5 is a bit better than the default 1/sqrt(3)
    bound = (3 ** 0.5) * std
    return w.uniform_(-bound, bound)

class Rotary(nn.Module):
    def __init__(self, dim: int, max_seq_len: int):
        super().__init__()
        # half-truncate RoPE by @YouJiacheng (w/ base freq tuning)
        angular_freq = (1 / 1024) ** torch.linspace(0, 1, steps=dim//4, dtype=torch.float32)
        angular_freq = torch.cat([angular_freq, angular_freq.new_zeros(dim//4)])
        t = torch.arange(max_seq_len, dtype=torch.float32)
        theta = torch.einsum("i,j -> ij", t, angular_freq)
        self.cos = nn.Buffer(theta.cos(), persistent=False)
        self.sin = nn.Buffer(theta.sin(), persistent=False)

    def forward(self, x_BTHD: Tensor):
        assert self.cos.size(0) >= x_BTHD.size(-3)
        cos, sin = self.cos[None, :x_BTHD.size(-3), None, :], self.sin[None, :x_BTHD.size(-3), None, :]
        x1, x2 = x_BTHD.to(dtype=torch.float32).chunk(2, dim=-1)
        y1 = x1 * cos + x2 * sin
        y2 = x1 * (-sin) + x2 * cos
        return torch.cat((y1, y2), 3).type_as(x_BTHD)

class CausalSelfAttention(nn.Module):
    def __init__(self, dim: int, num_heads: int, max_seq_len: int, head_dim=128):
        super().__init__()
        self.num_heads = num_heads
        self.head_dim = head_dim
        hdim = num_heads * head_dim
        # merged QKV weights: suggested by many, implemented by @fernbear.bsky.social, and further improved by @YouJiacheng
        # https://x.com/hi_tysam/status/1879699187107033311
        self.qkvo_w = nn.Parameter(init_linear(torch.empty(4, hdim, dim)).bfloat16())
        self.qkvo_w.detach()[3].zero_() # out zero init suggested by @Grad62304977
        self.rotary = Rotary(head_dim, max_seq_len)
        # scale the attention logits by given constant, instead of the default head_dim**-0.5, by @leloykun
        # inspired by learnable scalars used by @brendanh0gan https://x.com/hi_tysam/status/1879693583898591283
        self.attn_scale = 0.12

    def forward(self, x: Tensor, ve: Tensor | None, block_mask: BlockMask, lambdas: Tensor):
        B, T = x.size(0), x.size(1) # batch size, sequence length
        assert B == 1, "Must use batch size = 1 for FlexAttention"
        q, k, v = F.linear(x, self.qkvo_w[:3].flatten(end_dim=1)).view(B, T, 3 * self.num_heads, self.head_dim).chunk(3, dim=-2)
        q, k = norm(q), norm(k) # QK norm @Grad62304977
        q, k = self.rotary(q), self.rotary(k)
        v = norm(v)
        if ve is not None:
            v = lambdas[0] * v + lambdas[1] * ve.view_as(v) # @KoszarskyB & @Grad62304977
        else: # skip mid-layers token value embeddings by @YouJiacheng
            v = lambdas[0] * v
        y = flex_attention(q.transpose(1, 2), k.transpose(1, 2), v.transpose(1, 2), block_mask=block_mask, scale=self.attn_scale).transpose(1, 2)
        y = y.contiguous().view(B, T, self.num_heads * self.head_dim) # re-assemble all head outputs side by side
        y = F.linear(y, self.qkvo_w[3])
        return y

class MLP(nn.Module):
    def __init__(self, dim: int):
        super().__init__()
        hdim = 4 * dim
        self.fc_w = nn.Parameter(init_linear(torch.empty(hdim, dim)).bfloat16())
        self.proj_w = nn.Parameter(torch.zeros(dim, hdim).bfloat16())
        self.fc_w.wd_mul = 2.0
        self.proj_w.wd_mul = 2.0

    def forward(self, x: Tensor):
        x = F.linear(x, self.fc_w)
        x = F.relu(x).square() # https://arxiv.org/abs/2109.08668v2; ~1-2% better than GELU; suggested by @SKYLINEZ007 and @Grad62304977
        x = F.linear(x, self.proj_w)
        return x

class Block(nn.Module):
    def __init__(self, dim: int, num_heads: int, max_seq_len: int, layer_idx: int):
        super().__init__()
        # skip attention of blocks.7 (the 8th layer) by @YouJiacheng
        self.attn = CausalSelfAttention(dim, num_heads, max_seq_len) if layer_idx != 7 else None
        self.mlp = MLP(dim)

    def forward(self, x: Tensor, ve: Tensor | None, x0: Tensor, block_mask: BlockMask, lambdas: Tensor, sa_lambdas: Tensor):
        x = lambdas[0] * x + lambdas[1] * x0
        if self.attn is not None:
            x = x + self.attn(x, ve, block_mask, sa_lambdas)
        x = x + self.mlp(norm(x))
        return x

# -----------------------------------------------------------------------------
# The main model

def next_multiple_of_n(v: float | int, *, n: int):
    return next(x for x in range(n, int(v) + 1 + n, n) if x >= v)

class GPT(nn.Module):
    def __init__(self, vocab_size: int, num_layers: int, num_heads: int, model_dim: int, max_seq_len: int):
        super().__init__()
        self.embed = nn.Embedding(vocab_size, model_dim)
        # token value embeddings by @KoszarskyB - inspired by @Grad62304977's value residual implementation following https://arxiv.org/abs/2410.17897
        # value embedding code simplification inspired by @ragulpr https://github.com/KellerJordan/modded-nanogpt/pull/78
        self.value_embeds = nn.ModuleList([nn.Embedding(vocab_size, model_dim) for _ in range(3)])
        self.blocks = nn.ModuleList([Block(model_dim, num_heads, max_seq_len, i) for i in range(num_layers)])
        # there are only 50257 unique GPT-2 tokens; we extend to nearest multiple of 128 for efficiency.
        # suggested to me by @Grad62304977. this originates from Karpathy's experiments.
        self.lm_head_w = nn.Parameter(torch.zeros(next_multiple_of_n(vocab_size, n=128), model_dim))
        # Add learnable skip connection weights for decoder layers
        assert num_layers % 2 == 0
        self.scalars = nn.Parameter(torch.cat([
            torch.ones(num_layers), # skip_weights
            *[torch.tensor([1.0, 0.0]) for _ in range(num_layers)], # block lambdas
            *[torch.tensor([0.5, 0.5]) for _ in range(num_layers)], # SA lambdas
        ]))

    def create_blockmasks(self, input_seq: Tensor, sliding_window_num_blocks: Tensor):
        BLOCK_SIZE = 128
        docs = (input_seq == 50256).cumsum(0)

        def document_causal(b, h, q_idx, kv_idx):
            causal_mask = q_idx >= kv_idx
            document_mask = docs[q_idx] == docs[kv_idx]
            return causal_mask & document_mask

        def dense_to_ordered(dense_blockmask: Tensor):
            num_blocks = dense_blockmask.sum(dim=-1, dtype=torch.int32)
            indices = dense_blockmask.argsort(dim=-1, descending=False, stable=True).flip(-1).to(torch.int32)
            return num_blocks[None, None].contiguous(), indices[None, None].contiguous()

        # manual block mask creation by @YouJiacheng
        assert len(input_seq) % BLOCK_SIZE == 0
        NUM_BLOCKS = len(input_seq) // BLOCK_SIZE
        block_idx = torch.arange(NUM_BLOCKS, dtype=torch.int32, device="cuda")
        causal_blockmask_any = block_idx[:, None] >= block_idx
        causal_blockmask_all = block_idx[:, None] > block_idx
        docs_low = docs.view(-1, BLOCK_SIZE)[:, 0].contiguous()
        docs_high = docs.view(-1, BLOCK_SIZE)[:, -1].contiguous()
        document_blockmask_any = (docs_low[:, None] <= docs_high) & (docs_high[:, None] >= docs_low)
        document_blockmask_all = (docs_low[:, None] == docs_high) & (docs_high[:, None] == docs_low)
        blockmask_any = causal_blockmask_any & document_blockmask_any
        blockmask_all = causal_blockmask_all & document_blockmask_all
        partial_kv_num_blocks, partial_kv_indices = dense_to_ordered(blockmask_any & ~blockmask_all)
        full_kv_num_blocks, full_kv_indices = dense_to_ordered(blockmask_all)
        def build_bm(window_size_blocks: Tensor) -> BlockMask:
            return BlockMask.from_kv_blocks(
                torch.clamp_max(partial_kv_num_blocks, torch.clamp_min(window_size_blocks - full_kv_num_blocks, 1)),
                partial_kv_indices,
                torch.clamp_max(full_kv_num_blocks, window_size_blocks - 1),
                full_kv_indices,
                BLOCK_SIZE=BLOCK_SIZE,
                mask_mod=document_causal,
            )
        # Long-short SWA block masks by @leloykun & @YouJiacheng, adapated from suggestion by @Grad62304977, following Gemma 2 paper
        return build_bm(sliding_window_num_blocks), build_bm(sliding_window_num_blocks // 2)

    def forward(self, input_seq: Tensor, target_seq: Tensor, sliding_window_num_blocks: Tensor):
        assert input_seq.ndim == 1

        ve = [value_embed(input_seq) for value_embed in self.value_embeds]
        # 012 ... 012 structure on token value embeddings by @YouJiacheng, improved on @leloykun's U-net structure
        ve = [ve[0], ve[1], ve[2]] + [None] * (len(self.blocks) - 6) + [ve[0], ve[1], ve[2]]
        assert len(ve) == len(self.blocks)

        long_bm, short_bm = self.create_blockmasks(input_seq, sliding_window_num_blocks)
        block_masks = [long_bm, short_bm, short_bm, short_bm, long_bm, short_bm, short_bm, short_bm, short_bm, short_bm, short_bm, long_bm, short_bm, short_bm, short_bm, long_bm]
        assert len(block_masks) == len(self.blocks)

        x = x0 = norm(self.embed(input_seq)[None]) # use of norm here by @Grad62304977

        skip_connections = []
        skip_map = {
            9: 6,
            10: 4,
            11: 2,
        }
        skip_weights = self.scalars[:len(self.blocks)]
        lambdas = self.scalars[1 * len(self.blocks): 3 * len(self.blocks)].view(-1, 2)
        sa_lambdas = self.scalars[3 * len(self.blocks): 5 * len(self.blocks)].view(-1, 2)
        for i in range(len(self.blocks)):
            if i in skip_map:
                x = x + skip_weights[skip_map[i]] * skip_connections[skip_map[i]]
            x = self.blocks[i](x, ve[i], x0, block_masks[i], lambdas[i], sa_lambdas[i])
            skip_connections.append(x)

        x = norm(x)
        if self.training:
            logits: Tensor = F.linear(x.flatten(end_dim=1), self.lm_head_w.bfloat16()).float()
            loss = F.cross_entropy(15 * logits * torch.rsqrt(logits.square() + 225), target_seq)
            return loss

        loss = 0
        for i in range(4):
            logits: Tensor = F.linear(x.flatten(end_dim=1).chunk(4)[i], self.lm_head_w.bfloat16()).float()
            loss += F.cross_entropy(15 * logits * torch.rsqrt(logits.square() + 225), target_seq.chunk(4)[i]) / 4
        return loss

# -----------------------------------------------------------------------------
# Our own simple Distributed Data Loader

def _load_data_shard(file: Path):
    header = torch.from_file(str(file), False, 256, dtype=torch.int32) # header is 256 int32
    assert header[0] == 20240520, "magic number mismatch in the data .bin file"
    assert header[1] == 1, "unsupported version"
    num_tokens = int(header[2]) # number of tokens (claimed)
    with file.open("rb", buffering=0) as f:
        tokens = torch.empty(num_tokens, dtype=torch.uint16, pin_memory=True) # avoid pin_memory copy by @YouJiacheng
        f.seek(256 * 4)
        nbytes = f.readinto(tokens.numpy()) # avoid bytes->array copy by @YouJiacheng
        assert nbytes == 2 * num_tokens, "number of tokens read does not match header"
    return tokens

def distributed_data_generator(filename_pattern: str, batch_size: int, rank : int, world_size : int):
    files = sorted(Path.cwd().glob(filename_pattern))
    assert batch_size % world_size == 0
    local_batch_size = batch_size // world_size
    file_iter = iter(files) # use itertools.cycle(files) instead if you want to do multi-epoch training
    tokens, pos = _load_data_shard(next(file_iter)), 0
    while True:
        if pos + batch_size + 1 >= len(tokens):
            tokens, pos = _load_data_shard(next(file_iter)), 0
        buf = tokens[pos + rank * local_batch_size:][:local_batch_size + 1]
        inputs = buf[:-1].to(device="cuda", dtype=torch.int32, non_blocking=True) # no sync on host side;
        targets = buf[1:].to(device="cuda", dtype=torch.int64, non_blocking=True) # H2D in another stream isn't helpful.
        pos += batch_size
        yield inputs, targets

# -----------------------------------------------------------------------------
# int main

@dataclass
class Hyperparameters:
    # data
    train_files = "data/fineweb10B/fineweb_train_*.bin" # input .bin to train on
    val_files = "data/fineweb10B/fineweb_val_*.bin" # input .bin to eval validation loss on
    val_tokens = 10485760 # how many tokens of validation data? it's important to keep this fixed for consistent comparisons
    train_seq_len = 64*1024 # FlexAttention sequence length
    val_seq_len = 4*64*1024 # FlexAttention sequence length for validation
    # optimization
    num_iterations = 5960 # number of iterations to run
    cooldown_frac = 0.7 # fraction of training spent cooling down the learning rate
    # architecture
    vocab_size = 50257
    # evaluation and logging
    val_loss_every = 125 # every how many steps to evaluate val loss? 0 for only at the end
    save_checkpoint = False
args = Hyperparameters()

run_id = int(os.environ.get("RUN_ID", 0))
# torchrun sets these env variables
rank = int(os.environ["RANK"])
world_size = int(os.environ["WORLD_SIZE"])
assert world_size == 8 # this code is designed for 8xH100
assert torch.cuda.is_available()
device = torch.device("cuda", int(os.environ["LOCAL_RANK"]))
torch.cuda.set_device(device)
dist.init_process_group(backend="nccl", device_id=device)
dist.barrier()
master_process = (rank == 0) # this process will do logging, checkpointing etc.

# begin logging
if master_process:
    run_id_full = f"{run_id:03d}_{uuid.uuid4()}"
    os.makedirs("logs", exist_ok=True)
    logfile = f"logs/{run_id_full}.txt"
    print(logfile)
def print0(s, console=False):
    if master_process:
        with open(logfile, "a") as f:
            if console:
                print(s)
            print(s, file=f)
from torch._logging._internal import trace_structured # noqa: E402
import torch._inductor.codecache # noqa: E402
import torch._inductor.graph # noqa: E402
from torch._logging._internal import trace_structured as _orig_trace_structured
def _patched_trace_structured(name, *args, **kwargs):
    # metadata_fn may be positional, keyword, missing, or even a dict (already-evaluated metadata)
    metadata_fn = kwargs.get("metadata_fn", None)
    if metadata_fn is None and len(args) >= 1:
        metadata_fn = args[0]

    if name == "inductor_output_code":
        try:
            meta = None
            if callable(metadata_fn):
                meta = metadata_fn()
            elif isinstance(metadata_fn, dict):
                meta = metadata_fn
            if isinstance(meta, dict):
                filename = meta.get('filename', 'Unknown')
                print0(f"inductor_output_code: {filename}")
        except Exception:
            # Never let logging break compilation
            pass

    return _orig_trace_structured(name, *args, **kwargs)
torch._inductor.codecache.trace_structured = _patched_trace_structured
torch._inductor.graph.trace_structured = _patched_trace_structured

# begin by printing this file (the Python code)
print0(code)
print0("="*100)
# log information about the hardware/software environment this is running on
print0(f"Running Python {sys.version}")
print0(f"Running PyTorch {torch.version.__version__} compiled for CUDA {torch.version.cuda}")
def nvidia_smi():
    import subprocess  # avoid top level import
    return subprocess.run(["nvidia-smi"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True).stdout
print0(nvidia_smi())
print0("="*100)

########################################
#    Construct model and optimizer     #
########################################

model: nn.Module = GPT(vocab_size=args.vocab_size, num_layers=16, num_heads=8, model_dim=1024,
                       max_seq_len=max(args.train_seq_len, args.val_seq_len)).cuda()
for m in model.modules():
    if isinstance(m, nn.Embedding):
        m.bfloat16()
for param in model.parameters():
    dist.broadcast(param.detach(), 0)

# collect the parameters to optimize
hidden_matrix_params = sorted((p for p in model.blocks.parameters() if p.ndim >= 2), key=lambda x: x.size(), reverse=True)
embed_params = [*model.embed.parameters(), *model.value_embeds.parameters()]
scalar_params = [model.scalars]
head_params: list[nn.Parameter] = [model.lm_head_w]
# sanity check
params_collections = [hidden_matrix_params, embed_params, scalar_params, head_params]
optimized_parameters_set = {p for params in params_collections for p in params}
assert optimized_parameters_set == {*model.parameters()}
assert len(optimized_parameters_set) == sum(len(lst) for lst in params_collections)

# init the optimizer(s)
adam_param_groups = [dict(params=head_params, lr=1/320), dict(params=embed_params, lr=0.3), dict(params=scalar_params, lr=0.015)]
# small adam epsilon by @YouJiacheng. this is an alternate method of fixing the world_size dependence
# discovered by @fernbear.bsky.social https://x.com/hi_tysam/status/1879692937589875094
optimizer1 = torch.optim.AdamW(adam_param_groups, betas=(0.8, 0.95), eps=1e-10, weight_decay=0.0, fused=True)
optimizer2 = Muon(hidden_matrix_params, lr=0.025, momentum=0.95, rank=rank, world_size=world_size)
optimizers: list[torch.optim.Optimizer] = [optimizer1, optimizer2]
def opt_params(opt: torch.optim.Optimizer) -> list[nn.Parameter]:
    return [p for group in opt.param_groups for p in group["params"]]
opt2params = {opt: opt_params(opt) for opt in optimizers}
for opt in optimizers:
    for group in opt.param_groups:
        group["initial_lr"] = group["lr"]

# learning rate schedule: stable then decay
def get_lr(step: int):
    x = step / args.num_iterations # progress in training
    assert 0 <= x < 1
    if x < 1 - args.cooldown_frac:
        return 1.0
    else:
        return (1 - x) / args.cooldown_frac

# attention window size schedule: linearly increase
@lru_cache(1)
def get_window_size_blocks_helper(window_size: int):
    return torch.tensor(window_size // 128, dtype=torch.int32, pin_memory=True).cuda(non_blocking=True)
def get_window_size_blocks(step: int):
    x = step / args.num_iterations # progress in training
    assert 0 <= x <= 1
    # Linearly increase the block-wise sliding window size over training 128 -> 1792
    # increase by @fernbear.bsky.social; block-wise by @YouJiacheng
    factor = 4 * x ** 3 - 6 * x ** 2 + 3 * x # cubic schedule by @jadenj3o
    window_size = next_multiple_of_n(3456 * factor, n=128)
    return get_window_size_blocks_helper(window_size)

model: nn.Module = torch.compile(model, dynamic=False)

########################################
#            Warmup kernels            #
########################################

# Warmup the training kernels, then re-initialize the state so we aren't cheating
warmup_steps = 10
initial_state = copy.deepcopy(dict(model=model.state_dict(), optimizers=[opt.state_dict() for opt in optimizers]))
for _ in range(warmup_steps):
    inputs = targets = torch.randint(0, args.vocab_size, size=(args.train_seq_len,), device="cuda")
    model(inputs.to(torch.int32), targets, get_window_size_blocks(0)).backward()
    for param in model.parameters():
        dist.all_reduce(param.grad, op=dist.ReduceOp.AVG)
    for opt in optimizers:
        opt.step()
    model.zero_grad(set_to_none=True)
model.load_state_dict(initial_state["model"])
for opt, opt_state in zip(optimizers, initial_state["optimizers"]):
    opt.load_state_dict(opt_state)
del initial_state

########################################
#        Training and validation       #
########################################

torch.cuda.reset_peak_memory_stats()
train_loader = distributed_data_generator(args.train_files, world_size * args.train_seq_len, rank, world_size)
training_time_ms = 0
# start the clock
dist.barrier()
t0 = time.perf_counter()
# begin training
train_steps = args.num_iterations
for step in range(train_steps + 1):
    last_step = (step == train_steps)

    # --------------- VALIDATION SECTION -----------------
    if last_step or (args.val_loss_every > 0 and step % args.val_loss_every == 0):
        # stop the clock
        dist.barrier()
        training_time_ms += 1000 * (time.perf_counter() - t0)
        model.eval()
        val_batch_size = world_size * args.val_seq_len
        assert args.val_tokens % val_batch_size == 0
        val_steps = args.val_tokens // val_batch_size
        val_loader = distributed_data_generator(args.val_files, val_batch_size, rank, world_size)
        val_loss = 0
        with torch.no_grad():
            for _ in range(val_steps):
                inputs, targets = next(val_loader)
                val_loss += model(inputs, targets, get_window_size_blocks(step))
        val_loss /= val_steps
        del val_loader
        dist.all_reduce(val_loss, op=dist.ReduceOp.AVG)
        print0(f"step:{step}/{train_steps} val_loss:{val_loss:.6f} train_time:{training_time_ms:.0f}ms step_avg:{training_time_ms/max(step, 1):.2f}ms", console=True)
        model.train()
        # start the clock again
        dist.barrier()
        t0 = time.perf_counter()

    if last_step:
        if master_process and args.save_checkpoint:
            log = dict(step=step, code=code, model=model.state_dict(), optimizers=[opt.state_dict() for opt in optimizers])
            os.makedirs(f"logs/{run_id_full}", exist_ok=True)
            torch.save(log, f"logs/{run_id_full}/state_step{step:06d}.pt")
        # the last step only has the validation loop, so break to avoid training
        break

    # --------------- TRAINING SECTION -----------------
    inputs, targets = next(train_loader)
    model(inputs, targets, get_window_size_blocks(step)).backward()
    opt2futures = {
        opt: [dist.all_reduce(p.grad, op=dist.ReduceOp.AVG, async_op=True).get_future() for p in params]
        for opt, params in opt2params.items()
    }
    # set optimization hyperparameters
    for opt in optimizers:
        for group in opt.param_groups:
            group["lr"] = group["initial_lr"] * get_lr(step)
    for group in optimizer2.param_groups:
        frac = min(step / 300, 1) # momentum warmup for muon
        group["momentum"] = (1 - frac) * 0.85 + frac * 0.95
    # step the optimizers
    for opt in optimizers:
        torch.futures.collect_all(opt2futures[opt]).wait()
        opt.step()
    # null the gradients
    model.zero_grad(set_to_none=True)
    # logging
    approx_training_time_ms = training_time_ms + 1000 * (time.perf_counter() - t0)
    print0(f"step:{step+1}/{train_steps} train_time:{approx_training_time_ms:.0f}ms step_avg:{approx_training_time_ms/(step + 1):.2f}ms", console=True)

print0(f"peak memory allocated: {torch.cuda.max_memory_allocated() // 1024 // 1024} MiB "
    f"reserved: {torch.cuda.max_memory_reserved() // 1024 // 1024} MiB", console=True)
dist.destroy_process_group()

====================================================================================================
Running Python 3.12.12 | packaged by Anaconda, Inc. | (main, Oct 21 2025, 20:16:04) [GCC 11.2.0]
Running PyTorch 2.10.0.dev20251102+cu126 compiled for CUDA 12.6
Mon Nov  3 04:26:19 2025       
+---------------------------------------------------------------------------------------+
| NVIDIA-SMI 535.161.08             Driver Version: 535.161.08   CUDA Version: 12.4     |
|-----------------------------------------+----------------------+----------------------+
| GPU  Name                 Persistence-M | Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp   Perf          Pwr:Usage/Cap |         Memory-Usage | GPU-Util  Compute M. |
|                                         |                      |               MIG M. |
|=========================================+======================+======================|
|   0  NVIDIA H100 80GB HBM3          On  | 00000001:00:00.0 Off |                    0 |
| N/A   26C    P0             106W / 700W |   5775MiB / 81559MiB |      0%      Default |
|                                         |                      |             Disabled |
+-----------------------------------------+----------------------+----------------------+
|   1  NVIDIA H100 80GB HBM3          On  | 00000002:00:00.0 Off |                    0 |
| N/A   28C    P0             113W / 700W |   1465MiB / 81559MiB |      0%      Default |
|                                         |                      |             Disabled |
+-----------------------------------------+----------------------+----------------------+
|   2  NVIDIA H100 80GB HBM3          On  | 00000003:00:00.0 Off |                    0 |
| N/A   26C    P0             109W / 700W |   1465MiB / 81559MiB |      0%      Default |
|                                         |                      |             Disabled |
+-----------------------------------------+----------------------+----------------------+
|   3  NVIDIA H100 80GB HBM3          On  | 00000008:00:00.0 Off |                    0 |
| N/A   26C    P0             112W / 700W |   1465MiB / 81559MiB |      0%      Default |
|                                         |                      |             Disabled |
+-----------------------------------------+----------------------+----------------------+
|   4  NVIDIA H100 80GB HBM3          On  | 00000009:00:00.0 Off |                    0 |
| N/A   26C    P0             111W / 700W |   1465MiB / 81559MiB |      0%      Default |
|                                         |                      |             Disabled |
+-----------------------------------------+----------------------+----------------------+
|   5  NVIDIA H100 80GB HBM3          On  | 0000000A:00:00.0 Off |                    0 |
| N/A   26C    P0             108W / 700W |   1465MiB / 81559MiB |      0%      Default |
|                                         |                      |             Disabled |
+-----------------------------------------+----------------------+----------------------+
|   6  NVIDIA H100 80GB HBM3          On  | 0000000B:00:00.0 Off |                    0 |
| N/A   24C    P0             107W / 700W |   1465MiB / 81559MiB |      0%      Default |
|                                         |                      |             Disabled |
+-----------------------------------------+----------------------+----------------------+
|   7  NVIDIA H100 80GB HBM3          Off | 0000000C:00:00.0 Off |                    0 |
| N/A   25C    P0             107W / 700W |   1465MiB / 81559MiB |      0%      Default |
|                                         |                      |             Disabled |
+-----------------------------------------+----------------------+----------------------+
                                                                                         
+---------------------------------------------------------------------------------------+
| Processes:                                                                            |
|  GPU   GI   CI        PID   Type   Process name                            GPU Memory |
|        ID   ID                                                             Usage      |
|=======================================================================================|
+---------------------------------------------------------------------------------------+

====================================================================================================
inductor_output_code: /tmp/torchinductor_tiger/cp/ccpzbrtkdokk264dqitqje3tltfjfubcrhcl3kyaxjny6d2j7ijy.py
inductor_output_code: /tmp/torchinductor_tiger/wd/cwdwocwhjqkybryduxkf7nyb3i324yaawto6ulyv5qdqpyibszlx.py
inductor_output_code: /tmp/torchinductor_tiger/vv/cvvvc4edljejgr2brxogtcwjuhfrsge6cq2qmvvxkdokvopgcxor.py
inductor_output_code: /tmp/torchinductor_tiger/km/ckmpfnowlpxfwrjjwzbiykeww5p23oikvjx4zl7nstuyc5qdnuou.py
inductor_output_code: /tmp/torchinductor_tiger/m2/cm2ukpywvwlsf4c5tx34llbksqb4fgo5wx4mt3qemgk4j2e7zpmy.py
inductor_output_code: /tmp/torchinductor_tiger/57/c57ypscrngnsrvybgkkahq7zeg6fmy52543pcpn5xxevyaql4gna.py
inductor_output_code: /tmp/torchinductor_tiger/dz/cdzu6dfdmmoiyvwywmscvfwtci4kfama2uhkkmjzqrugtoakb2kl.py
inductor_output_code: /tmp/torchinductor_tiger/52/c52bbxtfqif7kl5iogj53sftdhaqhgf5mwp3othfta56wfqy3l5v.py
inductor_output_code: /tmp/torchinductor_tiger/gl/cglc6ahjnt2l7twgzg2vmeiiq7nv7rvd5oyxwoohkgezdhgkbfr5.py
inductor_output_code: /tmp/torchinductor_tiger/th/cthz6kvfgdedaxt75rcjp4nnhfwvqcwuxf7z3y6boj7tuawyoewv.py
inductor_output_code: /tmp/torchinductor_tiger/7c/c7cfncjc7iroxqxhdtou63qo4ur45ifm6nnav4b2zxqrhzbeh42q.py
inductor_output_code: /tmp/torchinductor_tiger/3x/c3xnyri3csuzjsx7t2qo7gm4lgccewwebra2emgiuss4d4g7p5xr.py
inductor_output_code: /tmp/torchinductor_tiger/rs/crslwmuefsiiwgpiecxg3msm546uy4shkh5x7ioq7hknyuvebs5s.py
inductor_output_code: /tmp/torchinductor_tiger/vs/cvs2eyi4bj6y7lpocjcpmk5pjxvykock2pjy5j62uc2crnocm5bx.py
inductor_output_code: /tmp/torchinductor_tiger/p4/cp4dynodbhlp5yg4vo2x653qdz5szjrjx3somogtuxupgiztdfae.py
inductor_output_code: /tmp/torchinductor_tiger/4b/c4bct2y5ghk4vs5kdg4obvwcldrdgjg6w7stl4befwa27p4czhud.py
inductor_output_code: /tmp/torchinductor_tiger/b4/cb4vusbg3g55t6zsvmmq647aznqftv72fs24s72cnetycjw4i2bd.py
inductor_output_code: /tmp/torchinductor_tiger/72/c72wi53ztn5ct3yte3c67moiqfyelsplpnc7bovjmiwm2phrra6e.py
step:0/5960 val_loss:10.825840 train_time:0ms step_avg:0.08ms
step:1/5960 train_time:536ms step_avg:536.13ms
step:2/5960 train_time:749ms step_avg:374.55ms
step:3/5960 train_time:966ms step_avg:322.12ms
step:4/5960 train_time:1179ms step_avg:294.70ms
step:5/5960 train_time:1391ms step_avg:278.23ms
step:6/5960 train_time:1603ms step_avg:267.21ms
step:7/5960 train_time:1812ms step_avg:258.86ms
step:8/5960 train_time:2024ms step_avg:252.99ms
step:9/5960 train_time:2234ms step_avg:248.18ms
step:10/5960 train_time:2445ms step_avg:244.51ms
step:11/5960 train_time:2655ms step_avg:241.35ms
step:12/5960 train_time:2865ms step_avg:238.78ms
step:13/5960 train_time:3074ms step_avg:236.49ms
step:14/5960 train_time:3285ms step_avg:234.63ms
step:15/5960 train_time:3495ms step_avg:233.01ms
step:16/5960 train_time:3706ms step_avg:231.64ms
step:17/5960 train_time:3915ms step_avg:230.32ms
step:18/5960 train_time:4125ms step_avg:229.17ms
step:19/5960 train_time:4334ms step_avg:228.12ms
step:20/5960 train_time:4545ms step_avg:227.25ms
step:21/5960 train_time:4754ms step_avg:226.40ms
step:22/5960 train_time:4964ms step_avg:225.63ms
step:23/5960 train_time:5174ms step_avg:224.94ms
step:24/5960 train_time:5384ms step_avg:224.33ms
step:25/5960 train_time:5594ms step_avg:223.76ms
step:26/5960 train_time:5805ms step_avg:223.26ms
step:27/5960 train_time:6015ms step_avg:222.77ms
step:28/5960 train_time:6224ms step_avg:222.29ms
step:29/5960 train_time:6433ms step_avg:221.84ms
step:30/5960 train_time:6643ms step_avg:221.44ms
step:31/5960 train_time:6852ms step_avg:221.04ms
step:32/5960 train_time:7063ms step_avg:220.71ms
step:33/5960 train_time:7272ms step_avg:220.37ms
step:34/5960 train_time:7482ms step_avg:220.07ms
step:35/5960 train_time:7693ms step_avg:219.79ms
step:36/5960 train_time:7904ms step_avg:219.54ms
step:37/5960 train_time:8112ms step_avg:219.25ms
step:38/5960 train_time:8322ms step_avg:219.00ms
step:39/5960 train_time:8531ms step_avg:218.75ms
step:40/5960 train_time:8742ms step_avg:218.54ms
step:41/5960 train_time:8951ms step_avg:218.33ms
step:42/5960 train_time:9161ms step_avg:218.13ms
step:43/5960 train_time:9372ms step_avg:217.94ms
step:44/5960 train_time:9582ms step_avg:217.76ms
step:45/5960 train_time:9791ms step_avg:217.58ms
step:46/5960 train_time:10001ms step_avg:217.42ms
step:47/5960 train_time:10209ms step_avg:217.22ms
step:48/5960 train_time:10417ms step_avg:217.03ms
step:49/5960 train_time:10625ms step_avg:216.83ms
step:50/5960 train_time:10834ms step_avg:216.67ms
step:51/5960 train_time:11043ms step_avg:216.52ms
step:52/5960 train_time:11251ms step_avg:216.37ms
step:53/5960 train_time:11460ms step_avg:216.23ms
step:54/5960 train_time:11670ms step_avg:216.11ms
step:55/5960 train_time:11879ms step_avg:215.98ms
step:56/5960 train_time:12088ms step_avg:215.86ms
step:57/5960 train_time:12298ms step_avg:215.75ms
step:58/5960 train_time:12506ms step_avg:215.61ms
step:59/5960 train_time:12713ms step_avg:215.48ms
step:60/5960 train_time:12922ms step_avg:215.37ms
step:61/5960 train_time:13130ms step_avg:215.25ms
step:62/5960 train_time:13339ms step_avg:215.15ms
step:63/5960 train_time:13547ms step_avg:215.04ms
step:64/5960 train_time:13756ms step_avg:214.94ms
step:65/5960 train_time:13964ms step_avg:214.84ms
step:66/5960 train_time:14172ms step_avg:214.73ms
step:67/5960 train_time:14382ms step_avg:214.66ms
step:68/5960 train_time:14591ms step_avg:214.57ms
step:69/5960 train_time:14802ms step_avg:214.52ms
step:70/5960 train_time:15011ms step_avg:214.44ms
step:71/5960 train_time:15219ms step_avg:214.35ms
step:72/5960 train_time:15428ms step_avg:214.28ms
step:73/5960 train_time:15637ms step_avg:214.21ms
step:74/5960 train_time:15846ms step_avg:214.14ms
step:75/5960 train_time:16055ms step_avg:214.07ms
step:76/5960 train_time:16264ms step_avg:214.01ms
step:77/5960 train_time:16475ms step_avg:213.96ms
step:78/5960 train_time:16687ms step_avg:213.93ms
step:79/5960 train_time:16897ms step_avg:213.88ms
step:80/5960 train_time:17107ms step_avg:213.83ms
step:81/5960 train_time:17316ms step_avg:213.78ms
step:82/5960 train_time:17525ms step_avg:213.72ms
step:83/5960 train_time:17734ms step_avg:213.67ms
step:84/5960 train_time:17944ms step_avg:213.62ms
step:85/5960 train_time:18153ms step_avg:213.57ms
step:86/5960 train_time:18364ms step_avg:213.53ms
step:87/5960 train_time:18575ms step_avg:213.50ms
step:88/5960 train_time:18787ms step_avg:213.49ms
step:89/5960 train_time:18996ms step_avg:213.44ms
step:90/5960 train_time:19206ms step_avg:213.40ms
step:91/5960 train_time:19415ms step_avg:213.35ms
step:92/5960 train_time:19625ms step_avg:213.31ms
step:93/5960 train_time:19834ms step_avg:213.27ms
step:94/5960 train_time:20044ms step_avg:213.23ms
step:95/5960 train_time:20254ms step_avg:213.20ms
step:96/5960 train_time:20466ms step_avg:213.19ms
step:97/5960 train_time:20676ms step_avg:213.15ms
step:98/5960 train_time:20887ms step_avg:213.13ms
step:99/5960 train_time:21098ms step_avg:213.11ms
step:100/5960 train_time:21309ms step_avg:213.09ms
step:101/5960 train_time:21519ms step_avg:213.06ms
step:102/5960 train_time:21728ms step_avg:213.02ms
step:103/5960 train_time:21937ms step_avg:212.98ms
step:104/5960 train_time:22146ms step_avg:212.94ms
step:105/5960 train_time:22355ms step_avg:212.90ms
step:106/5960 train_time:22564ms step_avg:212.87ms
step:107/5960 train_time:22774ms step_avg:212.84ms
step:108/5960 train_time:22984ms step_avg:212.82ms
step:109/5960 train_time:23194ms step_avg:212.79ms
step:110/5960 train_time:23405ms step_avg:212.77ms
step:111/5960 train_time:23614ms step_avg:212.74ms
step:112/5960 train_time:23823ms step_avg:212.70ms
step:113/5960 train_time:24033ms step_avg:212.68ms
step:114/5960 train_time:24243ms step_avg:212.66ms
step:115/5960 train_time:24452ms step_avg:212.63ms
step:116/5960 train_time:24663ms step_avg:212.61ms
step:117/5960 train_time:24873ms step_avg:212.59ms
step:118/5960 train_time:25083ms step_avg:212.57ms
step:119/5960 train_time:25293ms step_avg:212.55ms
step:120/5960 train_time:25504ms step_avg:212.53ms
step:121/5960 train_time:25714ms step_avg:212.51ms
step:122/5960 train_time:25925ms step_avg:212.50ms
step:123/5960 train_time:26133ms step_avg:212.47ms
step:124/5960 train_time:26344ms step_avg:212.46ms
step:125/5960 train_time:26555ms step_avg:212.44ms
step:125/5960 val_loss:7.807319 train_time:26555ms step_avg:212.44ms
step:126/5960 train_time:26769ms step_avg:212.45ms
step:127/5960 train_time:26980ms step_avg:212.44ms
step:128/5960 train_time:27191ms step_avg:212.43ms
step:129/5960 train_time:27401ms step_avg:212.41ms
step:130/5960 train_time:27611ms step_avg:212.39ms
step:131/5960 train_time:27821ms step_avg:212.37ms
step:132/5960 train_time:28031ms step_avg:212.35ms
step:133/5960 train_time:28240ms step_avg:212.33ms
step:134/5960 train_time:28450ms step_avg:212.32ms
step:135/5960 train_time:28660ms step_avg:212.29ms
step:136/5960 train_time:28869ms step_avg:212.27ms
step:137/5960 train_time:29078ms step_avg:212.25ms
step:138/5960 train_time:29289ms step_avg:212.24ms
step:139/5960 train_time:29499ms step_avg:212.22ms
step:140/5960 train_time:29710ms step_avg:212.21ms
step:141/5960 train_time:29919ms step_avg:212.19ms
step:142/5960 train_time:30129ms step_avg:212.17ms
step:143/5960 train_time:30337ms step_avg:212.15ms
step:144/5960 train_time:30546ms step_avg:212.12ms
step:145/5960 train_time:30755ms step_avg:212.10ms
step:146/5960 train_time:30964ms step_avg:212.08ms
step:147/5960 train_time:31174ms step_avg:212.07ms
step:148/5960 train_time:31386ms step_avg:212.07ms
step:149/5960 train_time:31598ms step_avg:212.07ms
step:150/5960 train_time:31809ms step_avg:212.06ms
step:151/5960 train_time:32019ms step_avg:212.05ms
step:152/5960 train_time:32230ms step_avg:212.04ms
step:153/5960 train_time:32440ms step_avg:212.03ms
step:154/5960 train_time:32652ms step_avg:212.03ms
step:155/5960 train_time:32863ms step_avg:212.02ms
step:156/5960 train_time:33073ms step_avg:212.01ms
step:157/5960 train_time:33284ms step_avg:212.00ms
step:158/5960 train_time:33495ms step_avg:212.00ms
step:159/5960 train_time:33707ms step_avg:211.99ms
step:160/5960 train_time:33919ms step_avg:211.99ms
step:161/5960 train_time:34130ms step_avg:211.99ms
step:162/5960 train_time:34341ms step_avg:211.98ms
step:163/5960 train_time:34552ms step_avg:211.98ms
step:164/5960 train_time:34765ms step_avg:211.98ms
step:165/5960 train_time:34978ms step_avg:211.99ms
step:166/5960 train_time:35190ms step_avg:211.99ms
step:167/5960 train_time:35401ms step_avg:211.98ms
step:168/5960 train_time:35614ms step_avg:211.99ms
step:169/5960 train_time:35825ms step_avg:211.98ms
step:170/5960 train_time:36035ms step_avg:211.97ms
step:171/5960 train_time:36246ms step_avg:211.96ms
step:172/5960 train_time:36455ms step_avg:211.95ms
step:173/5960 train_time:36666ms step_avg:211.94ms
step:174/5960 train_time:36877ms step_avg:211.94ms
step:175/5960 train_time:37089ms step_avg:211.93ms
step:176/5960 train_time:37300ms step_avg:211.93ms
step:177/5960 train_time:37512ms step_avg:211.93ms
step:178/5960 train_time:37722ms step_avg:211.92ms
step:179/5960 train_time:37933ms step_avg:211.92ms
step:180/5960 train_time:38143ms step_avg:211.91ms
step:181/5960 train_time:38355ms step_avg:211.91ms
step:182/5960 train_time:38566ms step_avg:211.90ms
step:183/5960 train_time:38776ms step_avg:211.89ms
step:184/5960 train_time:38986ms step_avg:211.88ms
step:185/5960 train_time:39197ms step_avg:211.87ms
step:186/5960 train_time:39408ms step_avg:211.87ms
step:187/5960 train_time:39620ms step_avg:211.87ms
step:188/5960 train_time:39831ms step_avg:211.87ms
step:189/5960 train_time:40041ms step_avg:211.86ms
step:190/5960 train_time:40252ms step_avg:211.85ms
step:191/5960 train_time:40515ms step_avg:212.12ms
step:192/5960 train_time:40726ms step_avg:212.11ms
step:193/5960 train_time:40936ms step_avg:212.10ms
step:194/5960 train_time:41145ms step_avg:212.09ms
step:195/5960 train_time:41357ms step_avg:212.09ms
step:196/5960 train_time:41567ms step_avg:212.08ms
step:197/5960 train_time:41777ms step_avg:212.07ms
step:198/5960 train_time:41986ms step_avg:212.05ms
step:199/5960 train_time:42196ms step_avg:212.04ms
step:200/5960 train_time:42405ms step_avg:212.03ms
step:201/5960 train_time:42617ms step_avg:212.03ms
step:202/5960 train_time:42828ms step_avg:212.02ms
step:203/5960 train_time:43037ms step_avg:212.01ms
step:204/5960 train_time:43246ms step_avg:211.99ms
step:205/5960 train_time:43457ms step_avg:211.98ms
step:206/5960 train_time:43666ms step_avg:211.97ms
step:207/5960 train_time:43876ms step_avg:211.96ms
step:208/5960 train_time:44086ms step_avg:211.95ms
step:209/5960 train_time:44296ms step_avg:211.94ms
step:210/5960 train_time:44506ms step_avg:211.93ms
step:211/5960 train_time:44716ms step_avg:211.92ms
step:212/5960 train_time:44926ms step_avg:211.92ms
step:213/5960 train_time:45136ms step_avg:211.91ms
step:214/5960 train_time:45347ms step_avg:211.90ms
step:215/5960 train_time:45558ms step_avg:211.90ms
step:216/5960 train_time:45769ms step_avg:211.89ms
step:217/5960 train_time:45981ms step_avg:211.89ms
step:218/5960 train_time:46194ms step_avg:211.90ms
step:219/5960 train_time:46406ms step_avg:211.90ms
step:220/5960 train_time:46619ms step_avg:211.90ms
step:221/5960 train_time:46830ms step_avg:211.90ms
step:222/5960 train_time:47041ms step_avg:211.90ms
step:223/5960 train_time:47252ms step_avg:211.89ms
step:224/5960 train_time:47464ms step_avg:211.89ms
step:225/5960 train_time:47677ms step_avg:211.90ms
step:226/5960 train_time:47888ms step_avg:211.90ms
step:227/5960 train_time:48100ms step_avg:211.89ms
step:228/5960 train_time:48313ms step_avg:211.90ms
step:229/5960 train_time:48524ms step_avg:211.89ms
step:230/5960 train_time:48734ms step_avg:211.89ms
step:231/5960 train_time:48945ms step_avg:211.88ms
step:232/5960 train_time:49156ms step_avg:211.88ms
step:233/5960 train_time:49367ms step_avg:211.88ms
step:234/5960 train_time:49580ms step_avg:211.88ms
step:235/5960 train_time:49793ms step_avg:211.88ms
step:236/5960 train_time:50004ms step_avg:211.88ms
step:237/5960 train_time:50216ms step_avg:211.88ms
step:238/5960 train_time:50425ms step_avg:211.87ms
step:239/5960 train_time:50634ms step_avg:211.86ms
step:240/5960 train_time:50842ms step_avg:211.84ms
step:241/5960 train_time:51054ms step_avg:211.84ms
step:242/5960 train_time:51264ms step_avg:211.84ms
step:243/5960 train_time:51475ms step_avg:211.83ms
step:244/5960 train_time:51686ms step_avg:211.83ms
step:245/5960 train_time:51898ms step_avg:211.83ms
step:246/5960 train_time:52110ms step_avg:211.83ms
step:247/5960 train_time:52321ms step_avg:211.82ms
step:248/5960 train_time:52531ms step_avg:211.82ms
step:249/5960 train_time:52742ms step_avg:211.81ms
step:250/5960 train_time:52953ms step_avg:211.81ms
step:250/5960 val_loss:nan train_time:52954ms step_avg:211.81ms
step:251/5960 train_time:53166ms step_avg:211.82ms
step:252/5960 train_time:53378ms step_avg:211.82ms
step:253/5960 train_time:53589ms step_avg:211.82ms
step:254/5960 train_time:53800ms step_avg:211.81ms
step:255/5960 train_time:54012ms step_avg:211.81ms
step:256/5960 train_time:54224ms step_avg:211.81ms
step:257/5960 train_time:54436ms step_avg:211.81ms
step:258/5960 train_time:54646ms step_avg:211.81ms
step:259/5960 train_time:54858ms step_avg:211.81ms
step:260/5960 train_time:55070ms step_avg:211.81ms
step:261/5960 train_time:55283ms step_avg:211.81ms
step:262/5960 train_time:55494ms step_avg:211.81ms
step:263/5960 train_time:55707ms step_avg:211.81ms
step:264/5960 train_time:55919ms step_avg:211.81ms
